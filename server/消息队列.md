## 消息队列——基础问题
目的：
	-解耦、异步、削峰

RocketMQ（功能完备，扩展性佳）和kafka（多用于大数据领域）：分布式架构（高可用）

使用消息队列会出现什么问题：
	- 降低系统可用性：你想呀，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低
	- 增加系统复杂性：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，刺痛复杂性增大。

如何保证高可用（从MQ集群架构方面作答）
	- RocketMQ集群的多master模式、多master多slave异步复制模式、多master多slave同步双写模式
	- NameServer集群，就在Kafka中是用zookeeper代替，都是用来保存和发现master和slave用的
	- Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance
	- Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高

如何保证消息不被重复消费，幂等性：
	- 拿消息做数据库的insert操作，唯一主键确保不产生脏数据;
	- 拿消息做redis的set操作，set操作本来就是幂等操作；
	- 大招，使用第三方介质，做消费记录，给消息分配一个全局id，消费者开始消费前，做消费记录查询；

如何保证消息的顺序性：
	- 将消息放入一个消息队列中，只用一个消费者去消费该队列；
	- 保证入队有序

## 关于MQ消息队列(RabbitMQ、ZeroMQ、ActiveMQ等.)

      在高并发分布式环境下，由于来不及同步处理，请求往往发生堵塞，比如说，大量的insert、update之类的请求
同时到达数据库，直接导致无所的行锁和表锁，甚至最后请求会堆积过多，从而触发too many connections错误。

通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。

ACK机制-当消费者拿到消息的瞬间,队列中的消息立即删除.同时删除 前台页面,缓存库,数据库 .(ACK机制保证了性能的高效.)