## Redis（Remote Dictionary Server）
	- 基于内存，由C语言编写的高性能的Key-Value型的非关系型型数据库，它拥有丰富的数据类型，并可实现数据持久化，并通过集群和哨兵机制实现高可用。可用作数据库，高速缓存，简单消息队列、发布/订阅、排行榜/计数器

	Redis 集群没有使用一致性hash，而是引入了哈希槽的概念，Redis 集群有16384个哈希槽，每个key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash槽
。
	Redis默认支持16个数据库，可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库；
	hash表是一个用来存储Key-value键值对的集合。python中有许多数据类型都是使用hash表实现的，比如字典，集合，计数器等。

	1、String（字符串）：最常使用的类型，也是最简单的类型，主要用做简单的 KV 缓存。实际应用场景有：缓存、计数器、共享用户Session
	2、Hash：类似 Map 的一种结构，可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里。 
	3、List（有序列表）：通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。
		(1)Redis的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。
		(2)文章列表或者数据分页展示的应用，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。		 
	4、Set是无序集合，会自动去重。得基于Redis进行全局的 Set 去重，可以基于 Set 执行交集、并集、差集的操作，比如交集，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？两个查询一个Set搞定。		 
	5、Sorted Set：是排序的 Set，不仅可以去重还可以排序，写进去的时候给一个分数，结果会自动根据分数排序。
		1.排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。
		2.用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。微博热搜榜，就是有个后面的热度值，前面就是名称		 
	6、高级用法：
		- Bitmap ：位图是支持按 bit 位来存储信息，可以用来实现 布隆过滤器（BloomFilter）；
		- HyperLogLog ：供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；
		- Geospatial ：可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？		 
		- pub/sub：功能是订阅发布功能，可以用作简单的消息队列。
		- Pipeline：可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。
		- Lua：Redis 支持提交 Lua 脚本来执行一系列的功能。
	- 内存中，集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：ZRANGE user_scores 0 10 WITHSCORES ，Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。

## 2、特点：
	- 快：
		（1）redis数据存在内存中，类似于HashMap，查找和操作的时间复杂度都是O(1)；
		（2）采用单线程避免了不必要的上下文切换和竞争条件，锁的问题，多线程切换而导致的 CPU消耗；
		（3）网络层使用epoll解决高并发问题，使用多路I/O复用模型，非阻塞IO
		（4）使用自己构建的底层模型，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
		（5） 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
	- 支持事务：
		- 原子操作：事务中的命令要么全部被执行，要么全部都不执行。
		- redis事务处理的基础指令：MULTI（开启）、EXEC（触发并执行）、DISCARD（放弃）、WATCH（监视）
		- 事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行，在执行的过程中，不会被其他客户端发送来的命令请求所打断。
	
	- 功能丰富：
		- 丰富的数据类型（是实现其它个性化功能的基础）
		- 提供慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等功能。

	- 支持数据持久化：（RDB做镜像全量持久化，AOF做增量持久化）
		- RDB（Redis Database）：每隔一段时间将redis存储的数据生成快照并存储到磁盘等介质上，是对Redis中的数据执行周期性的持久化，主要通过fork和cow实现，fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。【缺点】耗时，耗性能(fork+io操作)，易丢失数据。
		- AOF（Append Only File）：对每条写入命令以append-only的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog，在下次重新启动时，只需把这些指令从前到后再重复执行一遍；【缺点】体积大，恢复速度慢。
		- 如果没有持久化数的需求，可以关闭RDB和AOF方式，这样redis将变成一个像memcache一样的纯内存数据库；
	
	- 主从同步：
		- 与memcached一样，为了保证效率，数据都是缓存在内存中。区别是redis会周期性的把更新的数据写入磁盘或者把修改的操作写入追加的记录文件，并且在此基础上实现master-slave（主从）同步；
		- 主从同步 & 从从同步
			- Redis可以使用主从同步 & 从从同步，第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可（有点类似数据库的binlog）；
		- 主从同步和数据持久化的RDB和AOF有着比密切的关系。
		- Redis的特性就是必须支撑读高并发的，让这个master机器去写，数据同步给别的slave机器，他们都拿去读，分发掉大量的请求，而且扩容的时候还可以轻松实现水平扩容。
	
	- 注意：单线程仅仅是说在网络请求这一模块上用一个线程处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理

## 3、集群

	- Redis Sentinal：（着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务）
		- 在分布式系统中监控redis主从服务器，当master出现故障时，无需人工干预即可实现故障转，避免了对业务的影响，提高了运维工作效率。
		- 其中三个特性： 1、保证高可用；2、监控各个节点；3、自动故障迁移；
			1、监控（Monitoring）：Sentinel会不断地检查你的主服务器和从服务器是否运作正常。
			2、提醒（Notification）：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。
			3、自动故障迁移（Automaticfailover）：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作。
		- 缺点：主从模式，切换需要时间丢数据，没有解决master写的压力
	
	- Redis Cluster：（解决单机瓶颈）
		- 使用集群的部署方式，并且是主从同步读写分离，类似Mysql的主从同步
		- Redis cluster支撑N 个Redis master node，每个master node都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。
		- 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
		- Redis 集群之间通过异步复制，集群最大节点数是16384，集群目前无法做数据库选择，默认在0数据库。
		- 集群的主从复制模型：为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。
		- 弱一致性：
			- Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。
		- 集群不可用：
			- 有 A，B，C 三个节点的集群，在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。
	
	- 在 Redis 集群中，sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。
	- Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。

## 4、数据淘汰：
	- Redis提供6种数据淘汰策略：
		- voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近频率最少数据淘汰
		- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
		- volatile-random：从已设置过期时间的数据集（server。db[i]。expires）中任意选择数据淘汰
		- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
		- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
		- no-enviction（驱逐）：禁止驱逐数据
	
	- 三种过期策略：定时，定期，惰性过期（只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存）	
	- Redis中同时使用了惰性过期和定期过期两种过期策略。

## 5、常见问题：
	- 对于哈希冲突问题，Redis 使用链表法来解决。
	- redis分布式锁：不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。
	
	- 用Redis做异步队列：使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
	- 用Redis做延时队列：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
	
	- 生产消费模型：使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。（但是，在消费者下线的情况下，生产的消息会丢失）得使用专业的消息队列如RocketMQ等。
	
	- Pipeline：可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。

	- 为什么选单线程的：因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。
	
	- Redis不能干什么？
		- 持久化太过频繁会增大Redis服务的压力，带来Redis性能下降。
		- 数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。
	
	- 怎么保证缓存和数据库数据的一致性？
		- 合理设置缓存的过期时间。
		- 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。
	
	- redis 怎么实现分布式锁？ ###
		- Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。
		- 占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。
	
	- redis 如何做内存优化？ ###
		- 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。
		- 比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。
	
	- Redis常见的性能问题和解决方案：
		1、master 最好不要做持久化工作，如 RDB 内存快照和AOF日志文件
		2、如果数据比较重要，某个 slave 开启AOF备份，策略设置成每秒同步一次
		3、为了主从复制的速度和连接的稳定性，master 和 Slave 最好在一个局域网内
		4、尽量避免在压力大得主库上增加从库
		5、主从复制不要采用网状结构，尽量是线性结构，Master<--Slave1<----Slave2 ....
	
	- redis 常见的性能问题 ###
		主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
		Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。
	
	- 如何降低Redis内存使用：
		1.使用正确的数据结构
		2.key长度越小占用内存越小（积少成多）
		3.value的值是否可以进行处理
		4.部分数据结构在长度较小、个数较少的情况下会采用节省空间的算法存储，可以与sharding结合减少总内存使用
		5.sharding：减少单机可使用内存量（虽然不会减少总内存量）
	
	- 如何减少请求Redis的延迟？
		1.使用正确的数据结构
		2.分层结构可减少只读命令的latency
		3.总体思路是减少通信次数，因此一般情况下，尽量在redis server一端处理好后返回结果。常用方法有 
			（1）有些数据结构有处理多条数据的命令，比如hmget代替多次hget 
			（2）用pipeline代替多条命令多次与redis通信 
			（3）用lua脚本代替pipeline、watch/multi/exec（悲观锁）等

## 6、加分项
	- 结合实际应用场景来介绍缓存的使用：
		- 例如调用后端服务接口获取信息时，可以使用本地+远程的多级缓存；
		- 对于动态排行榜类的场景可以考虑通过 Redis 的 Sorted set 来实现等等。
	- 分布式缓存设计和使用经验：
		- 项目中在什么场景使用过 Redis，使用了什么数据结构，解决哪类的问题；
		- 使用 MC 时根据预估值大小调整 McSlab 分配参数等等。
	- 了解缓存使用中可能产生的问题：
		- Redis 是单线程处理请求，应尽量避免耗时较高的单个请求任务，防止相互影响；
		- Redis 服务应避免和其他 CPU 密集型的进程部署在同一机器；或者禁用 Swap 内存交换，防止 Redis 的缓存数据交换到硬盘上，影响性能。再比如前面提到的 MC 钙化问题等等。
	- 了解 Redis 的典型应用场景：
		- 使用 Redis 来实现分布式锁；
		- 使用 Bitmap 来实现 BloomFilter（使用场景最多，可以避免缓存穿透）
		- 使用 HyperLogLog 来进行 UV 统计等等。
	- 知道 Redis4.0、5.0 中的新特性：
		- 支持多播的可持久化消息队列 Stream；
		- 通过 Module 系统来进行定制功能扩展。