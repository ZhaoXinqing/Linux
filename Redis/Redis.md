## Redis（Remote Dictionary Server）
	- 是一个基于内存的高性能Key-Value型数据库，拥有丰富的数据类型，并可实现数据持久化，并通过集群和哨兵机制实现高可用；
	- 是一个开源的，基于内存存储的，数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。

## 1、基础：
	- 哈希槽：
		Redis 集群没有使用一致性hash，而是引入了哈希槽的概念，Redis 集群有16384个哈希槽，每个key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。
	- 管道：
		- 一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复（异步）。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。
	- 数据库：
		- Redis支持多个数据库，默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库；
		- 每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。
	- hash表：
		- 用途十分广泛，通俗来讲，hash表是一个用来存储Key-value键值对的集合。python中有许多数据类型都是使用hash表实现的，比如字典，集合，计数器等。
		- hash表是怎么储存数据的：例如有一个数据{‘a’:1}，一个数组n我们hash（a）得到一个key的hash值这时候我们需要将value存储在数组中，于是index = hash（a）% len（n）通过Hash（a）得到一个整数类型，对数组长度取余，余数就是我们把value存在数组中位置的下表值。当我们查询到key的‘a’的value时，直接重复上面的公式就能得到value的下标，直接进行取值操作。
	
	- Redis中的数据结构
		- 五种数据类型：string（字符串）、hash（哈希）、list（列表），set（集合）和zset（有序集合）;
		- Redis中高级用户，还有几种数据结构 HyperLogLog、Geo、Pub/Sub
			1、String：
				- Redis中最常使用的类型，也是最简单的类型，主要用做简单的 KV 缓存。
				- String的实际应用场景有：缓存、计数器、共享用户Session
			2、Hash：
				- 类似 Map 的一种结构，可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。	 
			3、List：
				- 是有序列表，可以通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。比如可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来。
				- 使用场景：List本身就是我们在开发过程中比较常用的数据结构了
					- 1.消息队列：Redis的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。
					- 2.文章列表或者数据分页展示的应用：比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。		 
			4、Set：
				- 是无序集合，会自动去重。直接基于 Set 将系统里需要去重的数据扔进去，自动就给去重了，得基于Redis进行全局的 Set 去重。可以基于 Set 执行交集、并集、差集的操作，比如交集，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？操作简单，两个查询一个Set搞定。		 
			5、Sorted Set：
				- 是排序的 Set，不仅可以去重还可以排序，写进去的时候给一个分数，结果会自动根据分数排序。有序集合的使用场景与集合类似，但是set集合不是自动有序的，而Sorted set可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。
				- 使用场景
					1.排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。
					2.用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。
					微博热搜榜，就是有个后面的热度值，前面就是名称		 
			6、高级用法：
				- Bitmap ：位图是支持按 bit 位来存储信息，可以用来实现 布隆过滤器（BloomFilter）；
				- HyperLogLog ：供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；
				- Geospatial ：可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？		 
				- pub/sub：功能是订阅发布功能，可以用作简单的消息队列。
				- Pipeline：可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。
				- Lua：Redis 支持提交 Lua 脚本来执行一系列的功能。
			- 内存中，集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：ZRANGE user_scores 0 10 WITHSCORES ，Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。

## 2、特点：
	- 快：
		- 基于内存，由C语言编写：
			- 关系型数据库是基于磁盘，
			-redis数据存在内存中，类似于HashMap，查找和操作的时间复杂度都是O(1)；
		- 采用单线程：
			- 避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，
			- 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
		- 网络层使用epoll解决高并发问题
			-使用多路I/O复用模型，非阻塞IO
		- 使用自己构建的底层模型：
			- Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
		- 数据结构简单，对数据操作也简单：
			- Redis中的数据结构是专门进行设计的；
		
		- MySQL这样的关系型数据库，表的结构比较复杂，会包含很多字段，可以通过SQL语句，来实现非常复杂的查询需求。而Redis客户只包含“键”和“值”两部分，只能通过“键”来查询“值”。正是因为这样简单的存储结构，也让Redis的读写效率非常高。
		- Redis的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，比如字符串、列表、字典、集合、有序集合。
	
	- 功能丰富：
		- 丰富的数据类型（是实现其它个性化功能的基础）
		- 提供慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等功能。
	- 支持事务：
		- 原子操作：事务中的命令要么全部被执行，要么全部都不执行。
		- redis事务处理的基础指令：MULTI（开启）、EXEC（触发并执行）、DISCARD（放弃）、WATCH（监视）
		- 事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行，在执行的过程中，不会被其他客户端发送来的命令请求所打断。
	- 支持数据持久化，主从同步：
		- 与memcached一样，为了保证效率，数据都是缓存在内存中。区别是redis会周期性的把更新的数据写入磁盘或者把修改的操作写入追加的记录文件，并且在此基础上实现master-slave（主从）同步；
		- Redis 的持久化有两种方式，或者说有两种策略：RDB做镜像全量持久化，AOF做增量持久化。
			- RDB（Redis Database）：每隔一段时间将redis存储的数据生成快照并存储到磁盘等介质上，是对Redis中的数据执行周期性的持久化，主要通过fork和cow实现，fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。
				- 缺点：耗时，耗性能(fork+io操作)，易丢失数据。
			- AOF（Append Only File）：对每条写入命令以append-only的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog，在下次重新启动时，只需把这些指令从前到后再重复执行一遍；
				- 缺点：体积大，恢复速度慢。
		- RDB和AOF对比：
			-两种方式都可以把Redis内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去；一样的数据，AOF文件比RDB还要大
			- 对系统性能的影响
				- RDB对Redis的性能影响非常小，同步数据的时候他只是fork了一个子进程去做持久化的，且在数据恢复的时候速度比AOF来的快。
			- 数据完整性：
				- RDB都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。
				- AOF则最多丢一秒的数据，数据完整性更强。
			- 怎么用：
				- RDB更适合做冷备，AOF更适合做热备，官方建议两种方式同时使用，以便提供更可靠的持久化方案，两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。
				-真出什么问题时候，第一时间用RDB恢复（恢复速度快），然后使用AOF做数据补全；冷备热备一起上。
		- 如果没有持久化数的需求，可以关闭RDB和AOF方式，这样redis将变成一个像memcache一样的纯内存数据库；
	
		- 主从同步 & 从从同步
			- Redis可以使用主从同步 & 从从同步，第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可（有点类似数据库的binlog）；
		- 主从之间的数据怎么同步的么？
			- 主从同步和数据持久化的RDB和AOF有着比密切的关系。
			- Redis的特性就是必须支撑读高并发的，让这个master机器去写，数据同步给别的slave机器，他们都拿去读，分发掉大量的请求，而且扩容的时候还可以轻松实现水平扩容。
	
	- 单线程：
		- 注意：单线程仅仅是说在网络请求这一模块上用一个线程处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理

## 3、集群

	- Redis Sentinal：（着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务）
		- 在分布式系统中监控redis主从服务器，当master出现故障时，无需人工干预即可实现故障转，避免了对业务的影响，提高了运维工作效率。
		- 其中三个特性： 1、保证高可用；2、监控各个节点；3、自动故障迁移；
			1、监控（Monitoring）：Sentinel会不断地检查你的主服务器和从服务器是否运作正常。
			2、提醒（Notification）：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。
			3、自动故障迁移（Automaticfailover）：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作。
		- 缺点：主从模式，切换需要时间丢数据，没有解决master写的压力
	
	- Redis Cluster：（解决单机瓶颈）
		- 使用集群的部署方式，并且是主从同步读写分离，类似Mysql的主从同步
		- Redis cluster支撑N 个Redis master node，每个master node都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。
		- 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
		- Redis 集群之间通过异步复制，集群最大节点数是16384，集群目前无法做数据库选择，默认在0数据库。
		- 集群的主从复制模型：为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。
		- 弱一致性：
			- Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。
		- 集群不可用：
			- 有 A，B，C 三个节点的集群，在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。
	
	- 在 Redis 集群中，sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。
	- Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。

## 4、数据淘汰：
	-Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）
	
	- 内存回收：
		- Redis的内存回收主要围绕以下两个方面：
			1、Redis过期策略：删除过期时间的key值
			2、Redis淘汰策略：内存使用到达maxmemory上限时触发内存淘汰数据
	
	- key 失效机制
		- Redis 的 key 可以设置过期时间，过期后 Redis 采用主动和被动结合的失效机制，一个是和 MC 一样在访问时触发被动删除，另一种是定期的主动删除。
		- key的过期时间和永久有效命令分别用：EXPIRE 和 PERSIST 命令
		- 采用：定期+惰性+内存淘汰 的数据淘汰策略；
	
	- Redis提供6种数据淘汰策略：
		- voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近频率最少数据淘汰
		- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
		- volatile-random：从已设置过期时间的数据集（server。db[i]。expires）中任意选择数据淘汰
		- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
		- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
		- no-enviction（驱逐）：禁止驱逐数据
	
	- 三种过期策略：
		1.定时过期：
			- 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
		2.惰性过期：
			- 只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
		3.定期过期：
			- 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。	
	- Redis中同时使用了惰性过期和定期过期两种过期策略。

## 5、常见问题：
	- 对于哈希冲突问题，Redis 使用链表法来解决。
	
	- redis分布式锁有什么缺陷？
		- 不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。
	
	- 怎么用Redis做异步队列、延时队列
		- 使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
		- 使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
	
	- 实现生产一次消费多次呢？
		- 使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。
		- 但是，在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等。
	
	- 机器突然掉电会怎样？
		- 取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。
	
	- Pipeline有什么好处，为什么要用pipeline？**
		- 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。
		- 使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。
	
	- 使用场景：
		- 缓存，简单消息队列、发布/订阅、排行榜/计数器
	
	- redis 为什么是单线程的？
		- 因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。
		- Redis 的性能，普通笔记本轻松处理每秒几十万的请求。
		- 而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。
	
	- Redis不能干什么？
		- 滥用可能导致系统的不稳定、成本增高等问题；
		- 持久化太过频繁会增大Redis服务的压力，带来Redis性能下降。
		- 数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。
	
	- 怎么保证缓存和数据库数据的一致性？
		- 合理设置缓存的过期时间。
		- 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。
	
	- redis 怎么实现分布式锁？ ###
		- Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。
		- 占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。
	
	- redis 如何做内存优化？ ###
		- 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。
		- 比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。
	
	- Redis常见的性能问题和解决方案：
		1、master 最好不要做持久化工作，如 RDB 内存快照和AOF日志文件
		2、如果数据比较重要，某个 slave 开启AOF备份，策略设置成每秒同步一次
		3、为了主从复制的速度和连接的稳定性，master 和 Slave 最好在一个局域网内
		4、尽量避免在压力大得主库上增加从库
		5、主从复制不要采用网状结构，尽量是线性结构，Master<--Slave1<----Slave2 ....
	
	- redis 常见的性能问题 ###
		主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
		Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。
	
	- 如何降低Redis内存使用：
		1.使用正确的数据结构
		2.key长度越小占用内存越小（积少成多）
		3.value的值是否可以进行处理
		4.部分数据结构在长度较小、个数较少的情况下会采用节省空间的算法存储，可以与sharding结合减少总内存使用
		5.sharding：减少单机可使用内存量（虽然不会减少总内存量）
	
	- 如何减少请求Redis的延迟？
		1.使用正确的数据结构
		2.分层结构可减少只读命令的latency
		3.总体思路是减少通信次数，因此一般情况下，尽量在redis server一端处理好后返回结果。常用方法有 
			（1）有些数据结构有处理多条数据的命令，比如hmget代替多次hget 
			（2）用pipeline代替多条命令多次与redis通信 
			（3）用lua脚本代替pipeline、watch/multi/exec（悲观锁）等

## 6、加分项
	- 结合实际应用场景来介绍缓存的使用：
		- 例如调用后端服务接口获取信息时，可以使用本地+远程的多级缓存；
		- 对于动态排行榜类的场景可以考虑通过 Redis 的 Sorted set 来实现等等。
	- 分布式缓存设计和使用经验：
		- 项目中在什么场景使用过 Redis，使用了什么数据结构，解决哪类的问题；
		- 使用 MC 时根据预估值大小调整 McSlab 分配参数等等。
	- 了解缓存使用中可能产生的问题：
		- Redis 是单线程处理请求，应尽量避免耗时较高的单个请求任务，防止相互影响；
		- Redis 服务应避免和其他 CPU 密集型的进程部署在同一机器；或者禁用 Swap 内存交换，防止 Redis 的缓存数据交换到硬盘上，影响性能。再比如前面提到的 MC 钙化问题等等。
	- 了解 Redis 的典型应用场景：
		- 使用 Redis 来实现分布式锁；
		- 使用 Bitmap 来实现 BloomFilter（使用场景最多，可以避免缓存穿透）
		- 使用 HyperLogLog 来进行 UV 统计等等。
	- 知道 Redis4.0、5.0 中的新特性：
		- 支持多播的可持久化消息队列 Stream；
		- 通过 Module 系统来进行定制功能扩展。