## 进程
可以理解为是一个独立运行的程序单位，进程也是系统资源分配的最小单位。进程地址空间相互独立，且进程各都有自己的用户地址空间，所以必须通过内核才能进行数据交换。
常见的通信方式有：管道pipe、有名管道FIFO、消息队列MessageQueue、共享存储、信号量Semaphore、信号Signal、套接字Socket；

## 线程
是进程的子集，一个进程可能由多个线程组成，是CPU调度的最小单位，通过抢占式共享进程的独立资源；同一进程内的线程组内线程
适用场景：提高系统的资源利用率，适用于一些比较耗时和等待的操作（数据查询，网页响应），选择多线程标准：线程切换增加的额外开销要小于该线程能够消除的阻塞时间，才物有所值。
线程锁：进程中的多线程是资源共享的，通过加锁确保同一时间只有一个线程操作共享内存中的数据，解决数据访问安全问题。
线程池：类似于消息队列的消息异步处理，常用于多任务同时触发情况下，部分任务执行时间过长，导致请求被阻塞的情况。

## 协程
在GO语言里，协程Goroutine属于一种轻量级的线程。操作系统可以进行线程和进程的调度，本身具备并发能力，但进程的调度切换需要保存现场，耗费太多时间，代价高昂。Go语言并发就是基于这个思想在用户层再构建一级调度，将并发的粒度进一步降低。goroutine类似于”守护线程“，异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打印了。


## 协程（Goroutine）和线程对比：
1、调度开销更小：线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构；而Go运行的时候包涵一个自己的M:N调度技术的调度器，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。
2、栈空间更灵活： - 每个OS的线程都有一个固定大小（通常是2MB）的栈内存，用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。而goroutine在生命周期开始时只有一个2KB栈， 在go程序中，一次创建十万左右的goroutine也就200MB，而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。
3、goroutine没有一个特定的标识。
- 线程在在大部分支持多线程的操作系统和编程语言里，通常有一个整数或者指针的标识，可以让我们构建一个线程的局部存储，本质是一个以线程的标识作为键的全局map。
- goroutine是一种纯函数的理念，其中没有可供程序员访问的标识，因为它不希望滥用线程局部存储导致一个不健康的超距作用（函数的行为不仅取决于它的参数，还取决于运行它的线程标识）
