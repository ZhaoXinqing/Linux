## 进程
    - 进程我们可以理解为是一个独立运行的程序单位；
    - 系统会给进程分配独立的资源，进程也是系统资源分配的最小单位。
    
    【进程间通信：】
        - 在Linux环境下，进程地址空间相互独立，且进程各都有自己的用户地址空间，所以必须通过内核才能进行数据交换。
        - 常见的通信方式有：管道pipe、有名管道FIFO、消息队列MessageQueue、共享存储、信号量Semaphore、信号Signal、套接字Socket；
## 线程
    - 线程是进程的子集，一个进程可能由多个线程组成，线程是CPU调度的最小单位，同一进程内的线程组内线程通过抢占式共享进程的独立资源；
    - 采用多线程的原因是，提高多核系统的系统资源利用率，

    【多线程适用场景：】
        - 如果使用单线程，一些比较耗时和等待的操作（数据查询，网页响应），处理器只能等待这些操作返回结果后才能继续执行其它操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。
        - 例如用于爬取网页，当我们爬取那个网页转圈圈的时候让另一个线程继续爬取。这样就避免了资源浪费。（把时间都利用起来）
        - 请求资源是不需要CPU 进行计算的，这时我们可以开启多线程提高执行效率，如果是计算密集型任务，不建议使用多线程就，衡量的标准就是，线程切换增加的额外开销要小于该线程能够消除的阻塞时间，才叫物有所值。

    【线程加锁保护：】
        - 在一个进程中的多个线程是共享资源的，线程加锁通过确保同一时间只有一个线程操作共享内存中的数据，解决多线程并发情况下的数据访问安全问题。

    【线程池：】
        - 线程池类似于消息队列的消息异步处理，只要我们的系统之间交互不是强一致性的，又希望提高系统的吞吐量，我们就可以考虑使用线程池
        - 常用于【多任务同时触发，并可能某些任务执行时间过长，请求可能会被阻塞住的线程】

## 协程
    - 在GO语言里，协程Goroutine属于一种轻量级的线程。
    操作系统可以进行线程和进程的调度，本身具备并发能力，但进程的调度切换需要保存现场，耗费太多时间，代价高昂。Go语言并发就是基于这个思想使得应用程序在用户层再构建一级调度，将并发的粒度进一步降低。

    - 协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的。
    - goroutine类似于”守护线程“，异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打印了。

Goroutine和线程的区别?
    1、从调度上看，goroutine的调度开销远远小于线程调度开销。
        - OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。
        - Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。
    2、从栈空间上，goroutine的栈空间更加动态灵活。
        - 每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。
    3、goroutine没有一个特定的标识。
        - 在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。
        - goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。

    - 如果两个M都在一个CPU上运行，这就是并发；如果两个M在不同的CPU上运行，这就是并行。