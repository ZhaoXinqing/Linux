linux题：https://blog.csdn.net/shantf93/article/details/79775702
Linux题(2020版)：https://blog.csdn.net/ThinkWon/article/details/104588679

命令：https://www.runoob.com/linux/linux-command-manual.html
    - 总结：https://www.cnblogs.com/passzhang/p/8552757.html



CGroups是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如**CPU、内存、磁盘输入输出**等），可用于单个进程的资源控制，操作系统层次的虚拟化。
    1、限制进程组可使用的资源数量（Resource limiting ）：
    2、控制进程组的优先级控制（Prioritization ）：
    3、进程组隔离（Isolation），使用不同的namespace，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间。
    4、进程组控制（Control）比如使用freezer子系统可以将进程组挂起和恢复。

虚拟内存，SWAP概念：虚拟内存通过缺页中断为进程分配物理内存，内存总是有限的，当如果所有的物理内存都被占用了，可用内存不足时，Linux可以使用 SWAP 分区，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。

【进程】独立运行的程序单位，系统资源分配的最小单位，地址空间相互独立，进程间通过内核进行数据交换。常见的通信方式有：管道pipe、有名管道FIFO、消息队列MessageQueue、共享存储、信号量Semaphore、信号Signal、套接字Socket；
【线程】进程的子集、实例，是CPU调度的最小单位，线程间通过抢占式共享进程的独立资源，一个进程可能由多个线程组成。多线程可以提高系统的资源利用率，适用于一些比较耗时和等待的操作（如数据查询，网页响应），线程切换增加的额外开销要小于该线程能够消除的阻塞时间，才物有所值。【线程锁】进程中的多线程是资源共享的，通过加锁确保同一时间只有一个线程操作共享内存中的数据，解决数据访问安全问题。【线程池】类似于消息队列的消息异步处理，常用于多任务同时触发情况下，部分任务执行时间过长，导致请求被阻塞的情况。
【协程】协程Goroutine属于一种轻量级的线程。操作系统可以进行线程和进程的调度，本身具备并发能力，但进程和线程的调度切换需要保存现场，耗费太多时间，代价高昂。Go语言基于这个思想在用户层再构建一级调度，将并发的粒度进一步降低。goroutine类似于”守护线程“，是异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打印了。
【协程（Goroutine）和线程对比】1、调度开销更小，不需要保存上下文，由go语言结构来触发的，不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。2、栈空间更灵活： 每个OS的线程都有一个固定大小（通常是2MB）的栈内存，用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。而goroutine在生命周期开始时只有一个2KB栈，而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。

内存中的堆栈：
    【堆】是大家共有的空间，全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但记得用完了要还给操作系统，要不然就是内存泄露 
    【栈】是线程独有的，每个函数都有自己的栈，栈被用来在函数之间传递参数。保存其运行状态和局部自动变量的操作系统在切换线程的时候会自动切换栈，栈空间不需要在高级语言里面显示的分配和释放，由编译器自动分配释放，操作方式类似于数据结构中的栈。

Linux内核的五个模块：
1、进程调度：syscall，用户态、内核态，glibc库，系统调用（返回值是负值，表示错误，0表示正确）
    （1）Linux以进程作为系统资源分配的基本单位，并采用动态优先级的进程高级算法，保证各个进程使用处理机的合理性。进程调度模块主要是对进程使用的处理机进行管理和控制。
    【进程创建】：在Linux环境编程时，一般采用fork()/vfork()函数（fork 是 创建一个子进程，并把父进程的内存数据copy到子进程中；vfork是 创建一个子进程，并和父进程的内存数据share一起用）来创建新的进程，当然，那是在用户空间的函数，它会调用内核中的clone()系统调用，由clone()函数继续调用do_fork()完成进程的创建。
    【进程撤销】：进程终止后，需要通知内核以便内核释放进程所拥有的资源，包括内存、打开文件以及其他资源，如信号量。进程终止的一般方式是调用exit()库函数，该函数释放C函数库所分配的资源，执行编程者所注册的每个函数，并结束从系统回收进程的那个系统调用。
    【进程切换】：进程切换又称为任务切换、上下文切换。它是这样一种行为，为了控制进程的执行，内核挂起当前在CPU上运行的进程，并恢复以前挂起的某个进程的执行。在本质上，每个进程切换由两部分组成：1-切换页全局目录以安装一个新的地址空间；2-切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器，主要有switch_to()函数完成。
    【进程调度】：现代的Linux中，调度算法可以在固定时间内（与可运行进程数量无关）选中要运行的进程。首先，我们必须知道进程可以分为实时进程与普通进程。每个LInux进程总是按照如下的调度类型被调度：先进先出的实时进程、时间片轮转的实时进程、普通的分时进程。调度算法根据进程是普通进程还是实时进程而有很大不同。
2、内存管理：malloc(),free(),以页为单位分配和映射内存，虚拟内存（提高系统资源利用率），进程独有自己内存空间
    （1）Linux的内存管理模块采用先进的虚拟存储机制，实现对多进程的存储管理。它提供了十分可靠的存储保护措施，对进程赋予不同的权限，用户不能直接访问系统的程序和数据，保证了系统的安全性。同时，为每个用户进程分配一个相互独立的虚拟地址空间；
3、文件系统：
    （1）Linux 的文件系统模块采用先进的虚拟文件系统(VFS)技术，屏蔽了各种文件系统的差别，为处理各种不同的文件系统提供了统一的接口，支持多种不同的物理文件系统达90多种。同时，Linux把各种硬件设备看作一种特殊的文件来处理，用管理文件的方法管理设备，非常方便、有效。
4、进程通信：进程间数据的同步、共享和交换，通过内核作为中间媒介实现，管道、命名管道、消息队列、信号量、共享内存
    （1）进程间通信模块保证了Linux支持多种进程间通信机制，包括管道、命名管道、消息队列、信号量和共享内存等。
    （2）进程间通信主要用于控制不同进程之间在用户空间的同步、数据共享和交换。由于不同的用户进程拥有不同的进程空间，因此进程间的通信要借助于内核的中转来实现。一般情况下，当一个进程等待硬件操作完成时，会被挂起。当硬件操作完成，进程被恢复执行，而协调这个过程的就是进程间的通信机制
5、网络接口：
    （1）Linux具有最强大的网络功能。网络接口模块通过套接字(Socket)机制实现计算机之间的网络通信，并采用网络层次模型提供对多种网络协议和网络硬件设备的支持。
    （2）epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用select/poll的增强版本，能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU的利用率，原因是它无需遍历整个被侦听的描述符集，只要遍历哪些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了，除水平触发(LT)外，还支持边缘触发(ET)，这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。


## 内核的5个模块：
1、进程调度模块：系统调用(syscalls)是Linux内核与上层应用程序进行通信的唯一接口，
(1)系统调用的结果会在返回值中表现出来，负值为错误，0表示正确；
(2)系统调用将Linux整个体系分为用户态和内核态（内核空间和用户空间）
(3)从用户态到内核态有三种方式：系统调用、异常、外设中断；
(4)在Linux系统上，应用代码通过glibc库封装的函数，间接使用系统调用
(5)进程调度算法：先来先服务、短作业优先、时间片轮转调度算法、高响应比优先、优先权调度算法、多级队列调度算法(不同的就绪队列采用不同的调度算法)
(6)线程调度：抢占式调度、协作式调度（主动让出CPU，调用调度代码进行调度，如协程，没有中断机制一般无法真正做到抢占。）
(7)对于Linux调度，简单来说就是在内核态执行schedule函数，按照一定策略选出这个CPU核接下来要执行的线程，上下文切换到对应线程执行。
(8)对于用户线程调度，首先要切换到内核态，用户栈切到内核栈，在内核态调用schedule函数，选出下一个要被执行的线程，上下文切换，执行。
(9)Linux线程调度的上下文切换，主要由函数context_switch完成，主要完成相关寄存器和栈的切换，如果涉及到了进程(进程是资源管理的单位)切换，还会切换页目录进而切换进程地址空间。
(10)抢占式调度依赖的是中断机制，与Linux线程调度相比，Goroutine调度不支持抢占。不过在Go1.2后，如果goroutine涉及了函数调用，那么就可以做到一定程度的“抢占”。这个抢占式调度的原理则是在每个函数或方法的入口，加上一段额外的代码，让runtime有机会检查是否需要执行抢占度。这种解决方案只能说局部解决了“饿死”问题，对于没有函数调用，纯算法循环计算的G，scheduler依然无法抢占。
(11)死锁：在2个或多个并发进程中，如果每个进程持有某个资源而又都等待别的进程释放它们现在保持的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是2个或多个进程被无限期地阻塞、相互等待的一种状态。
①死锁产生的原因：系统资源不足，进程推进顺序非法
②死锁的解除和预防：对资源的分配给予合理规划，不让死锁产生的四个必要条件成立：
1)资源使用互斥：一个资源每次只能被一个进程使用；
2)资源不可剥夺：进程已获得资源，在未使用完之前，不能被其他进程强行剥夺，只能主动释放；
3)请求和保持：请求新的资源，自己的资源保持不释放状态；
4)循环等待：死锁产生的根本原因，资源循环等待，都不释放，产生死锁；

2、内存管理模块：
(1)内存是cpu和磁盘中间的缓冲层，多任务过程中可以大大提高cpu利用率；malloc()函数负责记录程序的内存申请使用情况，free()函数负责内存释放；
(2)系统启动时，操作系统将整个物理内存以4K为单位，划分为各个页。之后进行内存分配时，都以页为单位；
(3)虚拟内存：
①操作系统来说，虚拟内存就是一张张的对照表
②物理内存和进程之间的中间层，对资源进行更合理地调度，提高资源的利用率并提供和谐统一的抽象。
(4)所有的进程有各自的用户空间，但所有的进程都共享一个内核空间；
(5)内存堆栈：
①堆（二级缓存，调用速度略低）是大家共有的空间，全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以像系统要额外的堆，但记得用完了要还给操作系统，要不然就是内存泄露，程序结束时可能由OS回收；
②栈（一级缓存）是线程独有的，存放函数的参数值，局部变量的值等。栈在线程开始的时候初始化，每个线程的栈相互独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动切换栈，就是切换SS/ESP寄存器。栈空间由编译器自动分配释放；
③例如：在函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！函数返回，函数所在的栈被销毁，指针也跟着销毁，申请的内存在堆上是不会销毁的，所以，记得释放！内存堆和数据结构中的堆是两码事，分配类似于链表。
④水满则溢，堆栈是有一定容量限制的，当超出了该容量限制，就会发生溢出；
1)操作系统会自动给每个进程分配一个最大栈空间2M，如果超过了这个上限，就会导致递归函数执行终止，所以就会报错
2)同样的，如果你创建一个数组过大，会引起堆溢出，操作系统给每个进程分配的最大堆空间是4G，如果过大会导致堆溢出。
3)解决递归函数堆栈溢出的方法就是尾递归：就是在函数返回return时调用函数本身，而不使用其他表达式。这样执行的时候尾递归函数只会占用一个栈帧，就不会引起栈溢出。
4)预防堆栈溢出需要我们在编程时了解内存使用，尽可能不要定义特别大的数组，尽可能不要定义特别复杂的函数，如多个形参等。
⑤golang的栈的动态增长的，并且是放在堆上的，理论上可以相当的大，加入循环引用就能做到人为的stackoverflow，默认栈的最大大小也就1GB，另外如果Golang编译器，或者Marshal函数能够对递归的深度做出判断，超过一定深度就报错，在栈溢出前，抛出err，避免栈溢出，程序崩溃；

3、文件系统模块：目录结构
(1)/-根目录：每一个文件和目录都从从这里开始，只有root用户具有该目录下的写权限。此目录和/root目录不同，root目录是root用户的主目录。
(2)bin–用户二进制文件：系统的所有用户使用的命令都设在这里，例如：ps，ls，ping，grep，cp等。
(3)sbin–系统二进制文件：这个目录下的linux命令通常由系统管理员使用，对系统进行维护。例如：iptable，reboot，fdisk，ifconfig，swapon命令。
(4)etc–配置文件：包含所有程序所需的配置文件。也包含了用于启动/停止单个程序的启动和关闭shell脚本。例如：/etc/resolv.conf、/etc/logrotate.conf
(5)dev–设备文件：包含设备文件，这些包括终端设备、USB或连接到系统的任何设备。例如：/dev/tty1、/dev/usbmon0
(6)proc–进程信息：是一个虚拟的文件系统，包含有关正在运行的进程的信息。例如：/proc/{pid}目录中包含的与特定pid相关的信息。
(7)var–变量文件：var代表变量文件，这个目录下是一些内容增长的文件。包括，系统日志文件(/var/log)，包和数据库文件(/var/lib)，电子邮件(/var/mail)，打印队列(/var/spool)，锁文件(/var/lock)，多次重新启动需要的临时文件(/var/tmp)；
(8)tmp–临时文件：包含系统和用户创建的临时文件。当系统重启时，这个目录下的文件都将被删除。
(9)usr–用户程序：包含二进制文件、库文件、文档和二级程序源代码。
①usr/bin中包含用户程序的二进制文件。如果你在/bin中找不到用户二进制文件，在/usr/bin目录看看。例如：atd、cron、sshd、useradd、userdel。
②usr/lib中包含了/usr/bin和/usr/sbin用到的库。
③usr/local中包含了从源安装的用户程序。例如，当你从源安装Apache，它会在/usr/local/apach2中。
(10)home–Home目录：所有用户用home目录来存储他们的个人档案。例如：/home/join、/home/nikita
(11)boot–引导加载程序文件：包含引导加载程序相关文件。内核的initrd、vmlinux、grub文件位于/boot下。
(12)lib–库：包含支持位于/bin和/sbin下的二进制文件的库文件，库文件名为id*或lib*.so.*。例如：Id-2.11.1.so，libncurses.so.5.7
(13)opt–可选的附加应用程序：-opt代表opitional；包含从个别厂商的附加应用程序。附加应用程序应该安装在/opt/或者/opt/的子目录下。
(14)mnt–挂载目录：临时安装目录，系统管理员可以挂载文件系统。
(15)media–可移动媒体设备：用于挂载可移动设备的临时目录。举例来说，挂载CD-ROM的media/cdrom，挂载软盘驱动器的/media/floppy；
(16)srv–服务数据：srv代表服务。包含服务器特定服务相关的数据，例如，/srv/cvs包含cvs相关的数据。

4、进程通信（IPC：Inter-ProcessCommunication）模块：
(1)管道（pipe）：是一种半双工的通信方式，数据只能单向流动，而且只能在有父子进程关系的进程间使用。
(2)命名管道（namedpipe）：也是半双工的通信方式，但是它允许无亲缘关系关系进程间通信。
(3)信号（signal）：用于通知接收进程某一事件已经发生，是一种比较复杂的通信方式。
(4)信号量（semophere）：主要作为进程间以及同一进程内不同线程之间的同步手段。是一个可用来控制多个进程对共享资源访问的计数器。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
(5)消息队列（messagequeue）:是由消息组成的链表，存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递消息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
(6)共享内存（sharedmemory）:就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量等配合使用，来实现进程间的同步和通信。
(7)套接字（socket）：套接口也是进程间的通信机制，与其他通信机制不同的是它可用于不同及其间的进程通信。
(8)进程通信几种方式的比较：
①管道：速度慢、容量有限
②消息队列：容量收到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
③信号量：不能传递复杂信息，只能用来同步。
④共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。
(9)线程间通信：目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制；
①锁机制：
1)互斥锁：以排它方式防止数据结构被并发修改；
2)条件变量：始终与互斥锁一起使用，对条件的测试是在互斥锁的保护下进行的，条件变量可以以原子的方式进行阻塞进程，直到某个特定条件为真为止；
3)读写锁：允许多个线程同时读共享数据，而对写操作是互斥的；
②信号量机制：包括无名信号量和命名线程信号量
③信号机制：类似进程间的信号处理
(10)进程和线程：进程和线程的主要差别在于它们是操作系统对资源管理的不同方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的一个实例。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
(11)多线程：提高系统资源利用率，对于一些比较耗时和等待的操作（数据查询，网页响应，爬取网页），使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。计算密集型不建议使用多线程，衡量的标准就是，线程切换增加的额外开销要小于该线程能够消除的阻塞时间，才叫物有所值。
①线程锁：在一个进程中的多个线程是共享资源的，线程加锁通过确保同一时间只有一个线程操作共享内存中的数据，解决多线程并发情况下的数据访问安全问题。
②线程池：类似于消息队列的消息异步处理，只要我们的系统之间交互不是强一致性的，又希望提高系统的吞吐量，我们就可以考虑使用线程池，常用于多任务同时触发，并可能某些任务执行时间过长，请求可能会被阻塞住的线程；
(12)协程：操作系统可以进行线程和进程的调度，本身具备并发能力，但进程的调度切换需要保存现场，耗费太多时间，代价高昂。Go语言并发就是基于这个思想使得应用程序在用户层再构建一级调度，将并发的粒度进一步降低。
①协程的切换则是由用户控制的，而线程的切换是由操作系统控制的；
②goroutine类似于”守护线程“，异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打印了。
(13)线程锁: 主要用来给方法、代码块加锁。当某个方法或者代码块使用锁时，那么在同一时刻至多仅有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法 / 代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。 但是，其余线程是可以访问该对象中的非加锁代码块的。 　　
(14)进程锁: 也是为了控制同一操作系统中多个进程访问一个共享资源，只是因为程序的独立性，各个进程是无法控制其他进程对资源的访问的， 但是可以使用本地系统的信号量控制（操作系统基本知识）。

5、网络接口模块：Unix（like）中，一切皆文件。
(1)Socket、FIFO、管道、终端都是文件，一切都是流。在信息交换的过程中，实际都是对这些流进行的数据收发操作，简称I/O操作（系统调用read、write）。而流有很多，于是就用文件描述符（fd）来区分具体是哪个流。例如，我们创建了一个socket（网络io），系统调用会返回一个fd，对socket的任何操作都是对这个fd的操作（隐隐包含着一种分层与抽象的思想）；
(2)IO发生时（以networkI/Oread为例）涉及到两个系统对象：一个是调用这个IO的process（进程）或者thread（线程），一个是kernel系统内核；以及两个阶段（交互过程）：1、等待数据准备，2、将数据从内核copy到process中。IO模型的区别就是在这两个阶段上的差异。
①blocking（阻塞）IO：用户进程发起调用后，整个进程就会被阻塞，等待kernel进行数据准备，并将数据从系统内存copy到用户内存，然后kernel返回结果，进程接触阻塞状态（blockingIO的特点就是两个阶段都被block）；
②non-blocking（非阻塞）IO：用户进程发起操作，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error，用户进程就知道数据还没有准备好，于是就周期再发送read调用，直到kernel中数据准备好，再次接收到systemcall后，将数据copy到用户内存（这种模型效率很低）
③multiplexing（多路复用）IO：和blockingio差别不大，但它有两个systemcall，所以还更差一些，但是它可以处理多个connection，能处理更多连接：
1)其实就是select/epoll，也称为eventdriven（事件驱动）IO。
2)select/epoll的好处就是一个thread可以同时处理多个socket的IO，其基本原理就是select/epoll会不断轮询所负责的socket，当某个socket有数据到达了，就通知用户进程。当用户进程调用了select/epoll，整个进程就会被block，同时kernel会observe所有select/epoll负责的socket，任何一个socket中数据准备好之后，select/epoll就会返回，这时用户进程再调用readsystemcall，将数据从kernelcopy进用户内存。
④asynchronous（异步）IO：发起操作后，可以直接开始做其它事；从kernel的角度，当它收到一个异步io操作之后，首先会立刻返回，不会对用户进程产生任何block。然后会等待数据准备完成并将数据拷贝到用户内存中，完成之后kernel会给用户进程发送一个signal，告诉它read操作完成了。
1)阻塞和非阻塞是一种调用机制，只涉及到调用方（针对单个进程的执行状态），调用方等待IO操作完成后返回则为阻塞，无需等待IO操作完成便返回则为非阻塞（非阻塞的情况下，调用方常常需要主动去check，获得IO的操作结果）；
2)同步与异步是一种通信机制，涉及到调用方和被调用方（针对应用程序与内核而言）；同步过程中，进程触发IO操作并等待（阻塞）或者轮询的（非阻塞）去查看IO操作是否完成；异步过程中，进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。
3)同步和异步关注的是程序之间的协作关系。同步分为阻塞和非阻塞，异步则只有非阻塞。
⑤signaldriven（信号驱动）IO：
(3)多路复用：select、poll、epoll 模型的区别?
①select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。 这样所带来的缺点是：1、单个进程可监视的fd数量被限制；2、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大；3、对socket进行扫描时是线性扫描。
②poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历， 如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。 它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。 poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。
③epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。 在前面说到的复制问题上，epoll使用mmap减少复制开销。 还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd， epoll_wait便可以收到通知。
6、LVS（LinuxVirtualServer），Linux虚拟服务器：
(1)主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。它易用，配置非常简单，且有多种负载均衡的方法。它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。另外可扩展性也非常好。	
①LVS集群为三层结构:
1)负载调度器(loadbalancer)：这是LVS的核心部分，它好比我们网站MVC模型的Controller。它负责将客户的请求按照一定的算法分发到下一层不同的服务器进行处理，自己本身不做具体业务的处理。另外该层还可用监控下一层的状态，如果下一层的某台服务器不能正常工作了，它会自动把其剔除，恢复后又可用加上。该层由一台或者几台DirectorServer组成。
2)服务器池(serverpool)：一组真正执行client请求的服务器，一般是我们的web服务器；除了web，还有FTP，MAIL，DNS。
3)共享存储(sharedstorage)：它为serverpool提供了一个共享的存储区，很容易让服务器池拥有相同的内容，提供相同的服务。主要是提高上一层数据和为上一层保持数据一致。
(2)Namespace：是linux内核用来隔离内核资源，对全局系统资源的一种封装隔离，为docker等容器技术的出现和发展提供了基础条件；
①处于不同Namespace的进程拥有独立的全局系统资源（改变一个namespace中的系统资源只会影响当前namespace里的进程，对其他namespace中的进程没有影响）
②只有在同一个namespace下的进程可以感知彼此的变化，而对其它namespace中的进程一无所知；
③proc/[pid]/ns目录下会包含进程所属的namespace信息，命令：
1)通过clone()在创建新进程的同时创建namespace
2)通过setns()函数可以将当前进程加入到已有的namespace中
3)通过unshare函数可以在原进程上进行namespace隔离；
(3)CGroup：最初的目标是用来限制、控制与分离一个进程组的资源（CPU、内存、磁盘输入输出等），既整合现有的cpuset等子系统，也为未来开发新的子系统提供接口。现在的cgroups适用于多种应用场景：单个进程的资源控制，实现操作系统层次的虚拟化（OSLevelVirtualization）；功能：
①限制进程组可以使用的资源数量（Resourcelimiting），一旦进程组使用的内存达到限额再申请内存，就会触发OOM（outofmemory）；
②进程组的优先级控制：可以使用cpu子系统为某个进程组分配特定cpushare；
③记录进程组使用的资源数量（Accounting）：记录某个进程组使用的cpu时间；
④进程组隔离（Isolation）：使用ns子系统可以使不同的进程组使用不同的namespace，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间；
⑤程组控制（Control）：使用freezer子系统可以将进程组挂起和恢复。