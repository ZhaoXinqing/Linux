虚拟内存：
    针对不同进程，操作系统虽然表面上将系统的物理内存分配给了特定进程，其实只有在进程真正使用的时候才会配凑出内存块给内存使用，但进程来说，它们都以为自己占用了整个内存，而自己使用的物理内存的哪段地址，它们并不知道也无需关心，这种其欺骗的手段就是虚拟内存。
    
分页和页表：
    - 虚拟内存是操作系统里的概念，对操作系统来说，虚拟内存就是一张张的对照表。
    - 系统里的基本单位都是Byte字节，如果将每一个虚拟内存的Byte都对应到物理内存的地址，每个条目最少需要 8字节（32位虚拟地址->32位物理地址），在 4G 内存的情况下，就需要 32GB 的空间来存放对照表，那么这张表就大得真正的物理地址也放不下了，于是操作系统引入了页（Page）的概念。
    - 在系统启动时，操作系统将整个物理内存以 4K 为单位，划分为各个页。之后进行内存分配时，都以页为单位； 那么虚拟内存页对应物理内存页的映射表就大大减小了，4G 内存，只需要 8M 的映射表即可，一些进程没有使用到的虚拟内存，也并不需要保存映射关系，而且Linux 还为大内存设计了多级页表，可以进一页减少了内存消耗。操作系统虚拟内存到物理内存的映射表，就被称为页表。
    
内存寻址和分配：
    - 通过虚拟内存机制，每个进程都以为自己占用了全部内存，进程访问内存时，操作系统都会把进程提供的虚拟内存地址转换为物理地址，再去对应的物理地址上获取数据。CPU 中有一种硬件，内存管理单元 MMU（Memory Management Unit）专门用来将翻译虚拟内存地址。CPU 还为页表寻址设置了缓存策略，由于程序的局部性，其缓存命中率能达到 98%。
    - 页表内存在虚拟地址到物理地址的映射，而如果进程访问的物理地址还没有被分配，系统则会产生一个缺页中断，在中断处理时，系统切到内核态为进程虚拟地址分配物理地址。

虚拟内存功能：
    1-通过内存地址转换解决了多个进程访问内存冲突的问题；
    2-有助于进程进行内存管理，主要体现在：
        【内存完整性】：由于虚拟内存对进程的”欺骗”，每个进程都认为自己获取的内存是一块连续的地址。我们在编写应用程序时，就不用考虑大块地址的分配，总是认为系统有足够的大块内存即可。
        【安全】：由于进程访问内存时，都要通过页表来寻址，操作系统在页表的各个项目上添加各种访问权限标识位，就可以实现内存的权限控制。
    3-数据共享：
        通过虚拟内存更容易实现内存和数据的共享，系统只需要将各个进程的虚拟内存地址指向系统分配的共享内存地址即可。
    
SWAP概念：
    - 虚拟内存可以帮进程”扩充”内存。
    - 虚拟内存通过缺页中断为进程分配物理内存，内存总是有限的，当如果所有的物理内存都被占用了，可用内存不足时，Linux可以使用 SWAP 分区，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。