内存中的堆栈：
    - 内存中的堆：
        - 堆是大家共有的空间，全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以像系统要额外的堆，但记得用完了要还给操作系统，要不然就是内存泄露 
    - 内存中的栈：
        - 栈是线程独有的 ，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈相互独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显示的分配和释放。
    - 堆栈总结：
        - 栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收 
    - 举个例子：
        - 例如，在函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！函数返回，函数所在的栈被销毁，指针也跟着销毁，申请的内存在堆上是不会销毁的，所以，记得释放！ 内存堆和数据结构中的堆是两码事，分配类似于链表。
    - 堆栈空间分配
        - 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
        - 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收，分配方式倒是类似于链表。
    - 堆栈缓存方式
        - 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
        - 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
        - 堆栈数据结构区别
            - 堆（数据结构）：堆可以被看成是一棵树，如：堆排序。
            - 栈（数据结构）：一种先进后出的数据结构。 
    - 为什么会堆栈溢出
        - 原因就是，操作系统会自动给每个进程分配一个最大栈空间2M，如果超过了这个上限，就会导致递归函数执行终止，所以就会报错。递归就像你一直在往一个空间里放东西，也就是一直在入栈，调用一次会把内存地址进行一次入栈，直到调用结束，才会将地址出栈。想一想，是不是如果调用次数过多，入栈的内存地址大于2M，就会引起程序报错呢？
        - 同样的，如果你创建一个数组过大，会引起堆溢出，操作系统给每个进程分配的最大堆空间是4G，如果过大会导致堆溢出。
        - ※（调用一个方法，在这个方法执行前都会将之前的内存地址（也就是调用点）入栈，等被调用的方法执行完将地址出栈，程序根据这个数据返回调用点）
    - 解决递归函数堆栈溢出的方法就是尾递归：
        - 尾递归就是在函数返回return时调用函数本身，而不使用其他表达式。这样执行的时候尾递归函数只会占用一个栈帧，就不会引起栈溢出。
        - 预防栈溢出需要我们在编程时了解内存使用，尽可能不要定义特别大的数组，尽可能不要定义特别复杂的函数，如多个形参等。
    - golang的栈的动态增长的，并且是放在堆上的，理论上可以相当的大，那么怎么才能制造一个stack overflow 故障呢？其实只要人为的加入循环引用就能做到：
        - 默认栈的最大大小也就1GB。
        - 另外如果Golang编译器，或者Marshal函数能够对递归的深度做出判断，超过一定深度就报错，在栈溢出前，抛出err，避免栈溢出，程序崩溃