内存中的堆栈：
    - 内存中的堆：
        - 堆是大家共有的空间，全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以像系统要额外的堆，但记得用完了要还给操作系统，要不然就是内存泄露 
    - 内存中的栈：
        - 栈是线程独有的 ，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈相互独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显示的分配和释放。
    - 堆栈总结：
        - 栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收 
    - 举个例子：
        - 例如，在函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！函数返回，函数所在的栈被销毁，指针也跟着销毁，申请的内存在堆上是不会销毁的，所以，记得释放！ 内存堆和数据结构中的堆是两码事，分配类似于链表。

堆栈溢出：
    - 在内存储器（随机存储器）中开辟一个区域作为堆栈，叫软件堆栈；用寄存器构成的堆栈，叫硬件堆栈。

    - 堆栈（Stack）是一种抽象数据结构，是一组相同数据类型的组合，所有的操作均在堆栈顶端进行，具有“后进先出”的特性，即最后一个放入堆栈中的物体总是被最先拿出来。堆栈中两个最重要的是PUSH（进栈）和POP（出栈）， PUSH操作在堆栈的顶部加入一 个元素，POP操作相反， 在堆栈顶部移去一个元素， 并将堆栈的大小减一。水满则溢，堆栈是有一定容量限制的，当超出了该容量限制，就会发生溢出。

    - 堆栈是计算机科学领域重要的数据结构，它被用于多种数值计算领域。表达式求值是编译程序中较为常见的操作，在算术表达式求值的过程中，需要使用堆栈来保存表达式的中间值和运算符，堆栈使得表达式的中间运算过程的结果访问具有了一定的自动管理能力。大部分编译型程序设计语言具有程序递归特性，递归能够增强语言的表达能力和降低程序设计难度。递归程序的递归深度通常是不确定的，需要将子程序执行的返回地址保存到堆栈这种先进后出式的结构中，以保证子程序的返回地址的正确使用顺序。函数式程序设计语言中，不同子函数的参数的种类和个数是不相同的，编译器也是使用堆栈来存储子程序的参数

    - 堆栈空间分配
        - 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
        - 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收，分配方式倒是类似于链表。

    - 堆栈缓存方式
        - 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
        - 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
        - 堆栈数据结构区别
            - 堆（数据结构）：堆可以被看成是一棵树，如：堆排序。
            - 栈（数据结构）：一种先进后出的数据结构。
    
    - 为什么会堆栈溢出
        - 原因就是，操作系统会自动给每个进程分配一个最大栈空间2M，如果超过了这个上限，就会导致递归函数执行终止，所以就会报错。递归就像你一直在往一个空间里放东西，也就是一直在入栈，调用一次会把内存地址进行一次入栈，直到调用结束，才会将地址出栈。想一想，是不是如果调用次数过多，入栈的内存地址大于2M，就会引起程序报错呢？

        - 同样的，如果你创建一个数组过大，会引起堆溢出，操作系统给每个进程分配的最大堆空间是4G，如果过大会导致堆溢出。

        - ※（调用一个方法，在这个方法执行前都会将之前的内存地址（也就是调用点）入栈，等被调用的方法执行完将地址出栈，程序根据这个数据返回调用点）
    
    - 解决递归函数堆栈溢出的方法就是尾递归：
        - 尾递归就是在函数返回return时调用函数本身，而不使用其他表达式。这样执行的时候尾递归函数只会占用一个栈帧，就不会引起栈溢出。
        - 预防栈溢出需要我们在编程时了解内存使用，尽可能不要定义特别大的数组，尽可能不要定义特别复杂的函数，如多个形参等。

    - golang的栈的动态增长的，并且是放在堆上的，理论上可以相当的大，那么怎么才能制造一个stack overflow 故障呢？其实只要人为的加入循环引用就能做到：
        - 默认栈的最大大小也就1GB。
        - 另外如果Golang编译器，或者Marshal函数能够对递归的深度做出判断，超过一定深度就报错，在栈溢出前，抛出err，避免栈溢出，程序崩溃